{
  "version": 3,
  "sources": ["../../../../../../node_modules/@tsparticles/move-base/browser/Utils.js", "../../../../../../node_modules/@tsparticles/move-base/browser/BaseMover.js", "../../../../../../node_modules/@tsparticles/move-base/browser/index.js", "../../../../../../node_modules/@tsparticles/shape-circle/browser/Utils.js", "../../../../../../node_modules/@tsparticles/shape-circle/browser/CircleDrawer.js", "../../../../../../node_modules/@tsparticles/shape-circle/browser/index.js", "../../../../../../node_modules/@tsparticles/updater-color/browser/ColorUpdater.js", "../../../../../../node_modules/@tsparticles/updater-color/browser/index.js", "../../../../../../node_modules/@tsparticles/plugin-hex-color/browser/HexColorManager.js", "../../../../../../node_modules/@tsparticles/plugin-hex-color/browser/index.js", "../../../../../../node_modules/@tsparticles/plugin-hsl-color/browser/HslColorManager.js", "../../../../../../node_modules/@tsparticles/plugin-hsl-color/browser/index.js", "../../../../../../node_modules/@tsparticles/updater-opacity/browser/OpacityUpdater.js", "../../../../../../node_modules/@tsparticles/updater-opacity/browser/index.js", "../../../../../../node_modules/@tsparticles/updater-out-modes/browser/Utils.js", "../../../../../../node_modules/@tsparticles/updater-out-modes/browser/BounceOutMode.js", "../../../../../../node_modules/@tsparticles/updater-out-modes/browser/DestroyOutMode.js", "../../../../../../node_modules/@tsparticles/updater-out-modes/browser/NoneOutMode.js", "../../../../../../node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js", "../../../../../../node_modules/@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js", "../../../../../../node_modules/@tsparticles/updater-out-modes/browser/index.js", "../../../../../../node_modules/@tsparticles/plugin-rgb-color/browser/RgbColorManager.js", "../../../../../../node_modules/@tsparticles/plugin-rgb-color/browser/index.js", "../../../../../../node_modules/@tsparticles/updater-size/browser/SizeUpdater.js", "../../../../../../node_modules/@tsparticles/updater-size/browser/index.js", "../../../../../../node_modules/@tsparticles/basic/browser/index.js"],
  "sourcesContent": ["import { RotateDirection, clamp, getDistance, getDistances, getRandom, getRangeValue } from \"@tsparticles/engine\";\nconst half = 0.5,\n  double = 2,\n  minVelocity = 0,\n  identity = 1,\n  moveSpeedFactor = 60,\n  minSpinRadius = 0,\n  spinFactor = 0.01,\n  doublePI = Math.PI * double;\nexport function applyDistance(particle) {\n  const initialPosition = particle.initialPosition,\n    {\n      dx,\n      dy\n    } = getDistances(initialPosition, particle.position),\n    dxFixed = Math.abs(dx),\n    dyFixed = Math.abs(dy),\n    {\n      maxDistance\n    } = particle.retina,\n    hDistance = maxDistance.horizontal,\n    vDistance = maxDistance.vertical;\n  if (!hDistance && !vDistance) {\n    return;\n  }\n  const hasHDistance = (hDistance && dxFixed >= hDistance) ?? false,\n    hasVDistance = (vDistance && dyFixed >= vDistance) ?? false;\n  if ((hasHDistance || hasVDistance) && !particle.misplaced) {\n    particle.misplaced = !!hDistance && dxFixed > hDistance || !!vDistance && dyFixed > vDistance;\n    if (hDistance) {\n      particle.velocity.x = particle.velocity.y * half - particle.velocity.x;\n    }\n    if (vDistance) {\n      particle.velocity.y = particle.velocity.x * half - particle.velocity.y;\n    }\n  } else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n    particle.misplaced = false;\n  } else if (particle.misplaced) {\n    const pos = particle.position,\n      vel = particle.velocity;\n    if (hDistance && (pos.x < initialPosition.x && vel.x < minVelocity || pos.x > initialPosition.x && vel.x > minVelocity)) {\n      vel.x *= -getRandom();\n    }\n    if (vDistance && (pos.y < initialPosition.y && vel.y < minVelocity || pos.y > initialPosition.y && vel.y > minVelocity)) {\n      vel.y *= -getRandom();\n    }\n  }\n}\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta) {\n  applyPath(particle, delta);\n  const gravityOptions = particle.gravity,\n    gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -identity : identity;\n  if (moveDrift && moveSpeed) {\n    particle.velocity.x += moveDrift * delta.factor / (moveSpeedFactor * moveSpeed);\n  }\n  if (gravityOptions?.enable && moveSpeed) {\n    particle.velocity.y += gravityFactor * (gravityOptions.acceleration * delta.factor) / (moveSpeedFactor * moveSpeed);\n  }\n  const decay = particle.moveDecay;\n  particle.velocity.multTo(decay);\n  const velocity = particle.velocity.mult(moveSpeed);\n  if (gravityOptions?.enable && maxSpeed > minVelocity && (!gravityOptions.inverse && velocity.y >= minVelocity && velocity.y >= maxSpeed || gravityOptions.inverse && velocity.y <= minVelocity && velocity.y <= -maxSpeed)) {\n    velocity.y = gravityFactor * maxSpeed;\n    if (moveSpeed) {\n      particle.velocity.y = velocity.y / moveSpeed;\n    }\n  }\n  const zIndexOptions = particle.options.zIndex,\n    zVelocityFactor = (identity - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n  velocity.multTo(zVelocityFactor);\n  const {\n    position\n  } = particle;\n  position.addTo(velocity);\n  if (moveOptions.vibrate) {\n    position.x += Math.sin(position.x * Math.cos(position.y));\n    position.y += Math.cos(position.y * Math.sin(position.x));\n  }\n}\nexport function spin(particle, moveSpeed) {\n  const container = particle.container;\n  if (!particle.spin) {\n    return;\n  }\n  const spinClockwise = particle.spin.direction === RotateDirection.clockwise,\n    updateFunc = {\n      x: spinClockwise ? Math.cos : Math.sin,\n      y: spinClockwise ? Math.sin : Math.cos\n    };\n  particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n  particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n  particle.spin.radius += particle.spin.acceleration;\n  const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height),\n    halfMaxSize = maxCanvasSize * half;\n  if (particle.spin.radius > halfMaxSize) {\n    particle.spin.radius = halfMaxSize;\n    particle.spin.acceleration *= -identity;\n  } else if (particle.spin.radius < minSpinRadius) {\n    particle.spin.radius = minSpinRadius;\n    particle.spin.acceleration *= -identity;\n  }\n  particle.spin.angle += moveSpeed * spinFactor * (identity - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n  const particlesOptions = particle.options,\n    pathOptions = particlesOptions.move.path,\n    pathEnabled = pathOptions.enable;\n  if (!pathEnabled) {\n    return;\n  }\n  if (particle.lastPathTime <= particle.pathDelay) {\n    particle.lastPathTime += delta.value;\n    return;\n  }\n  const path = particle.pathGenerator?.generate(particle, delta);\n  if (path) {\n    particle.velocity.addTo(path);\n  }\n  if (pathOptions.clamp) {\n    particle.velocity.x = clamp(particle.velocity.x, -identity, identity);\n    particle.velocity.y = clamp(particle.velocity.y, -identity, identity);\n  }\n  particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n  return particle.slow.inRange ? particle.slow.factor : identity;\n}\nexport function initSpin(particle) {\n  const container = particle.container,\n    options = particle.options,\n    spinOptions = options.move.spin;\n  if (!spinOptions.enable) {\n    return;\n  }\n  const spinPos = spinOptions.position ?? {\n      x: 50,\n      y: 50\n    },\n    spinFactor = 0.01,\n    spinCenter = {\n      x: spinPos.x * spinFactor * container.canvas.size.width,\n      y: spinPos.y * spinFactor * container.canvas.size.height\n    },\n    pos = particle.getPosition(),\n    distance = getDistance(pos, spinCenter),\n    spinAcceleration = getRangeValue(spinOptions.acceleration);\n  particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\n  particle.spin = {\n    center: spinCenter,\n    direction: particle.velocity.x >= minVelocity ? RotateDirection.clockwise : RotateDirection.counterClockwise,\n    angle: getRandom() * doublePI,\n    radius: distance,\n    acceleration: particle.retina.spinAcceleration\n  };\n}", "import { getRangeMax, getRangeValue } from \"@tsparticles/engine\";\nimport { applyDistance, getProximitySpeedFactor, initSpin, move, spin } from \"./Utils.js\";\nconst diffFactor = 2,\n  defaultSizeFactor = 1,\n  defaultDeltaFactor = 1;\nexport class BaseMover {\n  init(particle) {\n    const options = particle.options,\n      gravityOptions = options.move.gravity;\n    particle.gravity = {\n      enable: gravityOptions.enable,\n      acceleration: getRangeValue(gravityOptions.acceleration),\n      inverse: gravityOptions.inverse\n    };\n    initSpin(particle);\n  }\n  isEnabled(particle) {\n    return !particle.destroyed && particle.options.move.enable;\n  }\n  move(particle, delta) {\n    const particleOptions = particle.options,\n      moveOptions = particleOptions.move;\n    if (!moveOptions.enable) {\n      return;\n    }\n    const container = particle.container,\n      pxRatio = container.retina.pixelRatio;\n    particle.retina.moveSpeed ??= getRangeValue(moveOptions.speed) * pxRatio;\n    particle.retina.moveDrift ??= getRangeValue(particle.options.move.drift) * pxRatio;\n    const slowFactor = getProximitySpeedFactor(particle),\n      baseSpeed = particle.retina.moveSpeed * container.retina.reduceFactor,\n      moveDrift = particle.retina.moveDrift,\n      maxSize = getRangeMax(particleOptions.size.value) * pxRatio,\n      sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : defaultSizeFactor,\n      deltaFactor = delta.factor || defaultDeltaFactor,\n      moveSpeed = baseSpeed * sizeFactor * slowFactor * deltaFactor / diffFactor,\n      maxSpeed = particle.retina.maxSpeed ?? container.retina.maxSpeed;\n    if (moveOptions.spin.enable) {\n      spin(particle, moveSpeed);\n    } else {\n      move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta);\n    }\n    applyDistance(particle);\n  }\n}", "import { BaseMover } from \"./BaseMover.js\";\nexport async function loadBaseMover(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addMover(\"base\", () => {\n    return Promise.resolve(new BaseMover());\n  }, refresh);\n}", "const double = 2,\n  doublePI = Math.PI * double,\n  minAngle = 0,\n  origin = {\n    x: 0,\n    y: 0\n  };\nexport function drawCircle(data) {\n  const {\n    context,\n    particle,\n    radius\n  } = data;\n  if (!particle.circleRange) {\n    particle.circleRange = {\n      min: minAngle,\n      max: doublePI\n    };\n  }\n  const circleRange = particle.circleRange;\n  context.arc(origin.x, origin.y, radius, circleRange.min, circleRange.max, false);\n}", "import { degToRad, isObject } from \"@tsparticles/engine\";\nimport { drawCircle } from \"./Utils.js\";\nconst sides = 12,\n  maxAngle = 360,\n  minAngle = 0;\nexport class CircleDrawer {\n  constructor() {\n    this.validTypes = [\"circle\"];\n  }\n  draw(data) {\n    drawCircle(data);\n  }\n  getSidesCount() {\n    return sides;\n  }\n  particleInit(container, particle) {\n    const shapeData = particle.shapeData,\n      angle = shapeData?.angle ?? {\n        max: maxAngle,\n        min: minAngle\n      };\n    particle.circleRange = !isObject(angle) ? {\n      min: minAngle,\n      max: degToRad(angle)\n    } : {\n      min: degToRad(angle.min),\n      max: degToRad(angle.max)\n    };\n  }\n}", "import { CircleDrawer } from \"./CircleDrawer.js\";\nexport async function loadCircleShape(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addShape(new CircleDrawer(), refresh);\n}", "import { getHslAnimationFromHsl, rangeColorToHsl, updateColor } from \"@tsparticles/engine\";\nexport class ColorUpdater {\n  constructor(container, engine) {\n    this._container = container;\n    this._engine = engine;\n  }\n  init(particle) {\n    const hslColor = rangeColorToHsl(this._engine, particle.options.color, particle.id, particle.options.reduceDuplicates);\n    if (hslColor) {\n      particle.color = getHslAnimationFromHsl(hslColor, particle.options.color.animation, this._container.retina.reduceFactor);\n    }\n  }\n  isEnabled(particle) {\n    const {\n        h: hAnimation,\n        s: sAnimation,\n        l: lAnimation\n      } = particle.options.color.animation,\n      {\n        color\n      } = particle;\n    return !particle.destroyed && !particle.spawning && (color?.h.value !== undefined && hAnimation.enable || color?.s.value !== undefined && sAnimation.enable || color?.l.value !== undefined && lAnimation.enable);\n  }\n  update(particle, delta) {\n    updateColor(particle.color, delta);\n  }\n}", "import { ColorUpdater } from \"./ColorUpdater.js\";\nexport async function loadColorUpdater(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addParticleUpdater(\"color\", container => {\n    return Promise.resolve(new ColorUpdater(container, engine));\n  }, refresh);\n}", "var RgbIndexes;\n(function (RgbIndexes) {\n  RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\n  RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\n  RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\n  RgbIndexes[RgbIndexes[\"a\"] = 4] = \"a\";\n})(RgbIndexes || (RgbIndexes = {}));\nconst shorthandHexRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i,\n  hexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i,\n  hexRadix = 16,\n  defaultAlpha = 1,\n  alphaFactor = 0xff;\nexport class HexColorManager {\n  constructor() {\n    this.key = \"hex\";\n    this.stringPrefix = \"#\";\n  }\n  handleColor(color) {\n    return this._parseString(color.value);\n  }\n  handleRangeColor(color) {\n    return this._parseString(color.value);\n  }\n  parseString(input) {\n    return this._parseString(input);\n  }\n  _parseString(hexColor) {\n    if (typeof hexColor !== \"string\") {\n      return;\n    }\n    if (!hexColor?.startsWith(this.stringPrefix)) {\n      return;\n    }\n    const hexFixed = hexColor.replace(shorthandHexRegex, (_, r, g, b, a) => {\n        return r + r + g + g + b + b + (a !== undefined ? a + a : \"\");\n      }),\n      result = hexRegex.exec(hexFixed);\n    return result ? {\n      a: result[RgbIndexes.a] !== undefined ? parseInt(result[RgbIndexes.a], hexRadix) / alphaFactor : defaultAlpha,\n      b: parseInt(result[RgbIndexes.b], hexRadix),\n      g: parseInt(result[RgbIndexes.g], hexRadix),\n      r: parseInt(result[RgbIndexes.r], hexRadix)\n    } : undefined;\n  }\n}", "import { HexColorManager } from \"./HexColorManager.js\";\nexport async function loadHexColorPlugin(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addColorManager(new HexColorManager(), refresh);\n}", "import { getRangeValue, hslToRgb, hslaToRgba, parseAlpha } from \"@tsparticles/engine\";\nvar HslIndexes;\n(function (HslIndexes) {\n  HslIndexes[HslIndexes[\"h\"] = 1] = \"h\";\n  HslIndexes[HslIndexes[\"s\"] = 2] = \"s\";\n  HslIndexes[HslIndexes[\"l\"] = 3] = \"l\";\n  HslIndexes[HslIndexes[\"a\"] = 5] = \"a\";\n})(HslIndexes || (HslIndexes = {}));\nexport class HslColorManager {\n  constructor() {\n    this.key = \"hsl\";\n    this.stringPrefix = \"hsl\";\n  }\n  handleColor(color) {\n    const colorValue = color.value,\n      hslColor = colorValue.hsl ?? color.value;\n    if (hslColor.h !== undefined && hslColor.s !== undefined && hslColor.l !== undefined) {\n      return hslToRgb(hslColor);\n    }\n  }\n  handleRangeColor(color) {\n    const colorValue = color.value,\n      hslColor = colorValue.hsl ?? color.value;\n    if (hslColor.h !== undefined && hslColor.l !== undefined) {\n      return hslToRgb({\n        h: getRangeValue(hslColor.h),\n        l: getRangeValue(hslColor.l),\n        s: getRangeValue(hslColor.s)\n      });\n    }\n  }\n  parseString(input) {\n    if (!input.startsWith(\"hsl\")) {\n      return;\n    }\n    const regex = /hsla?\\(\\s*(\\d+)\\s*[\\s,]\\s*(\\d+)%\\s*[\\s,]\\s*(\\d+)%\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i,\n      result = regex.exec(input),\n      minLength = 4,\n      defaultAlpha = 1,\n      radix = 10;\n    return result ? hslaToRgba({\n      a: result.length > minLength ? parseAlpha(result[HslIndexes.a]) : defaultAlpha,\n      h: parseInt(result[HslIndexes.h], radix),\n      l: parseInt(result[HslIndexes.l], radix),\n      s: parseInt(result[HslIndexes.s], radix)\n    }) : undefined;\n  }\n}", "import { HslColorManager } from \"./HslColorManager.js\";\nexport async function loadHslColorPlugin(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addColorManager(new HslColorManager(), refresh);\n}", "import { getRandom, getRangeValue, initParticleNumericAnimationValue, percentDenominator, updateAnimation } from \"@tsparticles/engine\";\nexport class OpacityUpdater {\n  constructor(container) {\n    this.container = container;\n  }\n  init(particle) {\n    const opacityOptions = particle.options.opacity,\n      pxRatio = 1;\n    particle.opacity = initParticleNumericAnimationValue(opacityOptions, pxRatio);\n    const opacityAnimation = opacityOptions.animation;\n    if (opacityAnimation.enable) {\n      particle.opacity.velocity = getRangeValue(opacityAnimation.speed) / percentDenominator * this.container.retina.reduceFactor;\n      if (!opacityAnimation.sync) {\n        particle.opacity.velocity *= getRandom();\n      }\n    }\n  }\n  isEnabled(particle) {\n    const none = 0;\n    return !particle.destroyed && !particle.spawning && !!particle.opacity && particle.opacity.enable && ((particle.opacity.maxLoops ?? none) <= none || (particle.opacity.maxLoops ?? none) > none && (particle.opacity.loops ?? none) < (particle.opacity.maxLoops ?? none));\n  }\n  reset(particle) {\n    if (particle.opacity) {\n      particle.opacity.time = 0;\n      particle.opacity.loops = 0;\n    }\n  }\n  update(particle, delta) {\n    if (!this.isEnabled(particle) || !particle.opacity) {\n      return;\n    }\n    updateAnimation(particle, particle.opacity, true, particle.options.opacity.animation.destroy, delta);\n  }\n}", "import { OpacityUpdater } from \"./OpacityUpdater.js\";\nexport async function loadOpacityUpdater(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addParticleUpdater(\"opacity\", container => {\n    return Promise.resolve(new OpacityUpdater(container));\n  }, refresh);\n}", "import { OutMode, OutModeDirection, getRangeValue } from \"@tsparticles/engine\";\nconst minVelocity = 0,\n  boundsMin = 0;\nexport function bounceHorizontal(data) {\n  if (data.outMode !== OutMode.bounce && data.outMode !== OutMode.split || data.direction !== OutModeDirection.left && data.direction !== OutModeDirection.right) {\n    return;\n  }\n  if (data.bounds.right < boundsMin && data.direction === OutModeDirection.left) {\n    data.particle.position.x = data.size + data.offset.x;\n  } else if (data.bounds.left > data.canvasSize.width && data.direction === OutModeDirection.right) {\n    data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n  }\n  const velocity = data.particle.velocity.x;\n  let bounced = false;\n  if (data.direction === OutModeDirection.right && data.bounds.right >= data.canvasSize.width && velocity > minVelocity || data.direction === OutModeDirection.left && data.bounds.left <= boundsMin && velocity < minVelocity) {\n    const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\n    data.particle.velocity.x *= -newVelocity;\n    bounced = true;\n  }\n  if (!bounced) {\n    return;\n  }\n  const minPos = data.offset.x + data.size;\n  if (data.bounds.right >= data.canvasSize.width && data.direction === OutModeDirection.right) {\n    data.particle.position.x = data.canvasSize.width - minPos;\n  } else if (data.bounds.left <= boundsMin && data.direction === OutModeDirection.left) {\n    data.particle.position.x = minPos;\n  }\n  if (data.outMode === OutMode.split) {\n    data.particle.destroy();\n  }\n}\nexport function bounceVertical(data) {\n  if (data.outMode !== OutMode.bounce && data.outMode !== OutMode.split || data.direction !== OutModeDirection.bottom && data.direction !== OutModeDirection.top) {\n    return;\n  }\n  if (data.bounds.bottom < boundsMin && data.direction === OutModeDirection.top) {\n    data.particle.position.y = data.size + data.offset.y;\n  } else if (data.bounds.top > data.canvasSize.height && data.direction === OutModeDirection.bottom) {\n    data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n  }\n  const velocity = data.particle.velocity.y;\n  let bounced = false;\n  if (data.direction === OutModeDirection.bottom && data.bounds.bottom >= data.canvasSize.height && velocity > minVelocity || data.direction === OutModeDirection.top && data.bounds.top <= boundsMin && velocity < minVelocity) {\n    const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\n    data.particle.velocity.y *= -newVelocity;\n    bounced = true;\n  }\n  if (!bounced) {\n    return;\n  }\n  const minPos = data.offset.y + data.size;\n  if (data.bounds.bottom >= data.canvasSize.height && data.direction === OutModeDirection.bottom) {\n    data.particle.position.y = data.canvasSize.height - minPos;\n  } else if (data.bounds.top <= boundsMin && data.direction === OutModeDirection.top) {\n    data.particle.position.y = minPos;\n  }\n  if (data.outMode === OutMode.split) {\n    data.particle.destroy();\n  }\n}", "import { OutMode, calculateBounds } from \"@tsparticles/engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\nexport class BounceOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [OutMode.bounce, OutMode.split];\n  }\n  update(particle, direction, delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    const container = this.container;\n    let handled = false;\n    for (const plugin of container.plugins.values()) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta, direction);\n      }\n      if (handled) {\n        break;\n      }\n    }\n    if (handled) {\n      return;\n    }\n    const pos = particle.getPosition(),\n      offset = particle.offset,\n      size = particle.getRadius(),\n      bounds = calculateBounds(pos, size),\n      canvasSize = container.canvas.size;\n    bounceHorizontal({\n      particle,\n      outMode,\n      direction,\n      bounds,\n      canvasSize,\n      offset,\n      size\n    });\n    bounceVertical({\n      particle,\n      outMode,\n      direction,\n      bounds,\n      canvasSize,\n      offset,\n      size\n    });\n  }\n}", "import { OutMode, ParticleOutType, Vector, getDistances, isPointInside } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class DestroyOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [OutMode.destroy];\n  }\n  update(particle, direction, _delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    const container = this.container;\n    switch (particle.outType) {\n      case ParticleOutType.normal:\n      case ParticleOutType.outside:\n        if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n          return;\n        }\n        break;\n      case ParticleOutType.inside:\n        {\n          const {\n              dx,\n              dy\n            } = getDistances(particle.position, particle.moveCenter),\n            {\n              x: vx,\n              y: vy\n            } = particle.velocity;\n          if (vx < minVelocity && dx > particle.moveCenter.radius || vy < minVelocity && dy > particle.moveCenter.radius || vx >= minVelocity && dx < -particle.moveCenter.radius || vy >= minVelocity && dy < -particle.moveCenter.radius) {\n            return;\n          }\n          break;\n        }\n    }\n    container.particles.remove(particle, particle.group, true);\n  }\n}", "import { OutMode, OutModeDirection, Vector, isPointInside } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class NoneOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [OutMode.none];\n  }\n  update(particle, direction, delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    if ((particle.options.move.distance.horizontal && (direction === OutModeDirection.left || direction === OutModeDirection.right)) ?? (particle.options.move.distance.vertical && (direction === OutModeDirection.top || direction === OutModeDirection.bottom))) {\n      return;\n    }\n    const gravityOptions = particle.options.move.gravity,\n      container = this.container,\n      canvasSize = container.canvas.size,\n      pRadius = particle.getRadius();\n    if (!gravityOptions.enable) {\n      if (particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius || particle.velocity.y < minVelocity && particle.position.y >= -pRadius || particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius || particle.velocity.x < minVelocity && particle.position.x >= -pRadius) {\n        return;\n      }\n      if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n        container.particles.remove(particle);\n      }\n    } else {\n      const position = particle.position;\n      if (!gravityOptions.inverse && position.y > canvasSize.height + pRadius && direction === OutModeDirection.bottom || gravityOptions.inverse && position.y < -pRadius && direction === OutModeDirection.top) {\n        container.particles.remove(particle);\n      }\n    }\n  }\n}", "import { OutMode, OutModeDirection, ParticleOutType, Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange } from \"@tsparticles/engine\";\nconst minVelocity = 0,\n  minDistance = 0;\nexport class OutOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [OutMode.out];\n  }\n  update(particle, direction, delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    const container = this.container;\n    switch (particle.outType) {\n      case ParticleOutType.inside:\n        {\n          const {\n            x: vx,\n            y: vy\n          } = particle.velocity;\n          const circVec = Vector.origin;\n          circVec.length = particle.moveCenter.radius;\n          circVec.angle = particle.velocity.angle + Math.PI;\n          circVec.addTo(Vector.create(particle.moveCenter));\n          const {\n            dx,\n            dy\n          } = getDistances(particle.position, circVec);\n          if (vx <= minVelocity && dx >= minDistance || vy <= minVelocity && dy >= minDistance || vx >= minVelocity && dx <= minDistance || vy >= minVelocity && dy <= minDistance) {\n            return;\n          }\n          particle.position.x = Math.floor(randomInRange({\n            min: 0,\n            max: container.canvas.size.width\n          }));\n          particle.position.y = Math.floor(randomInRange({\n            min: 0,\n            max: container.canvas.size.height\n          }));\n          const {\n            dx: newDx,\n            dy: newDy\n          } = getDistances(particle.position, particle.moveCenter);\n          particle.direction = Math.atan2(-newDy, -newDx);\n          particle.velocity.angle = particle.direction;\n          break;\n        }\n      default:\n        {\n          if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n            return;\n          }\n          switch (particle.outType) {\n            case ParticleOutType.outside:\n              {\n                particle.position.x = Math.floor(randomInRange({\n                  min: -particle.moveCenter.radius,\n                  max: particle.moveCenter.radius\n                })) + particle.moveCenter.x;\n                particle.position.y = Math.floor(randomInRange({\n                  min: -particle.moveCenter.radius,\n                  max: particle.moveCenter.radius\n                })) + particle.moveCenter.y;\n                const {\n                  dx,\n                  dy\n                } = getDistances(particle.position, particle.moveCenter);\n                if (particle.moveCenter.radius) {\n                  particle.direction = Math.atan2(dy, dx);\n                  particle.velocity.angle = particle.direction;\n                }\n                break;\n              }\n            case ParticleOutType.normal:\n              {\n                const warp = particle.options.move.warp,\n                  canvasSize = container.canvas.size,\n                  newPos = {\n                    bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                    left: -particle.getRadius() - particle.offset.x,\n                    right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                    top: -particle.getRadius() - particle.offset.y\n                  },\n                  sizeValue = particle.getRadius(),\n                  nextBounds = calculateBounds(particle.position, sizeValue);\n                if (direction === OutModeDirection.right && nextBounds.left > canvasSize.width + particle.offset.x) {\n                  particle.position.x = newPos.left;\n                  particle.initialPosition.x = particle.position.x;\n                  if (!warp) {\n                    particle.position.y = getRandom() * canvasSize.height;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                } else if (direction === OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n                  particle.position.x = newPos.right;\n                  particle.initialPosition.x = particle.position.x;\n                  if (!warp) {\n                    particle.position.y = getRandom() * canvasSize.height;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                }\n                if (direction === OutModeDirection.bottom && nextBounds.top > canvasSize.height + particle.offset.y) {\n                  if (!warp) {\n                    particle.position.x = getRandom() * canvasSize.width;\n                    particle.initialPosition.x = particle.position.x;\n                  }\n                  particle.position.y = newPos.top;\n                  particle.initialPosition.y = particle.position.y;\n                } else if (direction === OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n                  if (!warp) {\n                    particle.position.x = getRandom() * canvasSize.width;\n                    particle.initialPosition.x = particle.position.x;\n                  }\n                  particle.position.y = newPos.bottom;\n                  particle.initialPosition.y = particle.position.y;\n                }\n                break;\n              }\n          }\n          break;\n        }\n    }\n  }\n}", "import { OutMode, OutModeDirection } from \"@tsparticles/engine\";\nimport { BounceOutMode } from \"./BounceOutMode.js\";\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\nimport { NoneOutMode } from \"./NoneOutMode.js\";\nimport { OutOutMode } from \"./OutOutMode.js\";\nconst checkOutMode = (outModes, outMode) => {\n  return outModes.default === outMode || outModes.bottom === outMode || outModes.left === outMode || outModes.right === outMode || outModes.top === outMode;\n};\nexport class OutOfCanvasUpdater {\n  constructor(container) {\n    this._addUpdaterIfMissing = (particle, outMode, getUpdater) => {\n      const outModes = particle.options.move.outModes;\n      if (!this.updaters.has(outMode) && checkOutMode(outModes, outMode)) {\n        this.updaters.set(outMode, getUpdater(this.container));\n      }\n    };\n    this._updateOutMode = (particle, delta, outMode, direction) => {\n      for (const updater of this.updaters.values()) {\n        updater.update(particle, direction, delta, outMode);\n      }\n    };\n    this.container = container;\n    this.updaters = new Map();\n  }\n  init(particle) {\n    this._addUpdaterIfMissing(particle, OutMode.bounce, container => new BounceOutMode(container));\n    this._addUpdaterIfMissing(particle, OutMode.out, container => new OutOutMode(container));\n    this._addUpdaterIfMissing(particle, OutMode.destroy, container => new DestroyOutMode(container));\n    this._addUpdaterIfMissing(particle, OutMode.none, container => new NoneOutMode(container));\n  }\n  isEnabled(particle) {\n    return !particle.destroyed && !particle.spawning;\n  }\n  update(particle, delta) {\n    const outModes = particle.options.move.outModes;\n    this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, OutModeDirection.bottom);\n    this._updateOutMode(particle, delta, outModes.left ?? outModes.default, OutModeDirection.left);\n    this._updateOutMode(particle, delta, outModes.right ?? outModes.default, OutModeDirection.right);\n    this._updateOutMode(particle, delta, outModes.top ?? outModes.default, OutModeDirection.top);\n  }\n}", "import { OutOfCanvasUpdater } from \"./OutOfCanvasUpdater.js\";\nexport async function loadOutModesUpdater(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addParticleUpdater(\"outModes\", container => {\n    return Promise.resolve(new OutOfCanvasUpdater(container));\n  }, refresh);\n}", "import { getRangeValue, parseAlpha } from \"@tsparticles/engine\";\nvar RgbIndexes;\n(function (RgbIndexes) {\n  RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\n  RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\n  RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\n  RgbIndexes[RgbIndexes[\"a\"] = 5] = \"a\";\n})(RgbIndexes || (RgbIndexes = {}));\nexport class RgbColorManager {\n  constructor() {\n    this.key = \"rgb\";\n    this.stringPrefix = \"rgb\";\n  }\n  handleColor(color) {\n    const colorValue = color.value,\n      rgbColor = colorValue.rgb ?? color.value;\n    if (rgbColor.r !== undefined) {\n      return rgbColor;\n    }\n  }\n  handleRangeColor(color) {\n    const colorValue = color.value,\n      rgbColor = colorValue.rgb ?? color.value;\n    if (rgbColor.r !== undefined) {\n      return {\n        r: getRangeValue(rgbColor.r),\n        g: getRangeValue(rgbColor.g),\n        b: getRangeValue(rgbColor.b)\n      };\n    }\n  }\n  parseString(input) {\n    if (!input.startsWith(this.stringPrefix)) {\n      return;\n    }\n    const regex = /rgba?\\(\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i,\n      result = regex.exec(input),\n      radix = 10,\n      minLength = 4,\n      defaultAlpha = 1;\n    return result ? {\n      a: result.length > minLength ? parseAlpha(result[RgbIndexes.a]) : defaultAlpha,\n      b: parseInt(result[RgbIndexes.b], radix),\n      g: parseInt(result[RgbIndexes.g], radix),\n      r: parseInt(result[RgbIndexes.r], radix)\n    } : undefined;\n  }\n}", "import { RgbColorManager } from \"./RgbColorManager.js\";\nexport async function loadRgbColorPlugin(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addColorManager(new RgbColorManager(), refresh);\n}", "import { getRandom, percentDenominator, updateAnimation } from \"@tsparticles/engine\";\nconst minLoops = 0;\nexport class SizeUpdater {\n  init(particle) {\n    const container = particle.container,\n      sizeOptions = particle.options.size,\n      sizeAnimation = sizeOptions.animation;\n    if (sizeAnimation.enable) {\n      particle.size.velocity = (particle.retina.sizeAnimationSpeed ?? container.retina.sizeAnimationSpeed) / percentDenominator * container.retina.reduceFactor;\n      if (!sizeAnimation.sync) {\n        particle.size.velocity *= getRandom();\n      }\n    }\n  }\n  isEnabled(particle) {\n    return !particle.destroyed && !particle.spawning && particle.size.enable && ((particle.size.maxLoops ?? minLoops) <= minLoops || (particle.size.maxLoops ?? minLoops) > minLoops && (particle.size.loops ?? minLoops) < (particle.size.maxLoops ?? minLoops));\n  }\n  reset(particle) {\n    particle.size.loops = minLoops;\n  }\n  update(particle, delta) {\n    if (!this.isEnabled(particle)) {\n      return;\n    }\n    updateAnimation(particle, particle.size, true, particle.options.size.animation.destroy, delta);\n  }\n}", "import { SizeUpdater } from \"./SizeUpdater.js\";\nexport async function loadSizeUpdater(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await engine.addParticleUpdater(\"size\", () => {\n    return Promise.resolve(new SizeUpdater());\n  }, refresh);\n}", "import { loadBaseMover } from \"@tsparticles/move-base\";\nimport { loadCircleShape } from \"@tsparticles/shape-circle\";\nimport { loadColorUpdater } from \"@tsparticles/updater-color\";\nimport { loadHexColorPlugin } from \"@tsparticles/plugin-hex-color\";\nimport { loadHslColorPlugin } from \"@tsparticles/plugin-hsl-color\";\nimport { loadOpacityUpdater } from \"@tsparticles/updater-opacity\";\nimport { loadOutModesUpdater } from \"@tsparticles/updater-out-modes\";\nimport { loadRgbColorPlugin } from \"@tsparticles/plugin-rgb-color\";\nimport { loadSizeUpdater } from \"@tsparticles/updater-size\";\nexport async function loadBasic(engine, refresh = true) {\n  engine.checkVersion(\"3.8.1\");\n  await loadHexColorPlugin(engine, false);\n  await loadHslColorPlugin(engine, false);\n  await loadRgbColorPlugin(engine, false);\n  await loadBaseMover(engine, false);\n  await loadCircleShape(engine, false);\n  await loadColorUpdater(engine, false);\n  await loadOpacityUpdater(engine, false);\n  await loadOutModesUpdater(engine, false);\n  await loadSizeUpdater(engine, false);\n  await engine.refresh(refresh);\n}"],
  "mappings": "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",
  "names": ["spinFactor", "double", "doublePI", "minAngle", "RgbIndexes", "HslIndexes", "defaultAlpha", "minVelocity", "minVelocity", "minVelocity", "minVelocity", "RgbIndexes", "defaultAlpha"]
}
